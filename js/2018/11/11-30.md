``` javascript
  // 1. js运算符优先级表
  // 2. 2018大厂高级前端面试题汇总解答

    var obj = {
       say: function () {
            function _say () {
              console.log(this) // window
            }   
            console.log(obj) // undefind
            return _say.bind(obj) // obj 相当于null 默认绑定window
       }()
     }
     obj.say()
```

``` javascript
     var str = 'abcexyzab12345abggabc'
     // 去掉abc
     console.log(str.replace(/[abc]/g, ''))

     // 给数字加上[1][2][3][4][5]
     console.log(str.replace(/\d/g, '[$&]'))

     // 数字乘以2
     console.log(str.split('').map(v => {
       return /\d$/.test(v) ? v * 2 : v
     }).join(''))
```

``` javascript
     // 
     var x = 5, 
          y = 'abc'
      function outFun () {
        var x =  10,
              y   =  'xyz'
        function innerFun () {
              x = 20
              var y = 'faasd'
        }      
        innerFun()
        console.log(x)
        console.log(y)
      }    
      outFun() //  20 xyz
      console.log(x) // 5
      console.log(y) // abc
```

``` javascript
    // this引用的是函数执行的环境对象
    var num = 1;
    var myObject = {
        num: 2,
        add: function() {
            this.num = 3;
            (function() {
                // 立即执行函数和闭包的this指向windows
                console.log(this.num);
                this.num = 4;
            })();
            console.log(this.num);
        },
        sub: function() {
            console.log(this.num)
        }
    }
    //  闭包的this指向window
    myObject.add(); // 3 1
    console.log(myObject.num); // 3
    console.log(num); // 4
    // 赋值后 sub 的this指向Windows
    var sub = myObject.sub;
    sub.call(); // 4

```


``` javascript
    // debounce防抖
    function debounce (fn, delay) {
        var self = this,
              args = arguments
              return function () {
                    clearTimeout(fn.id)
                    fn.id = setTimeout( function () {
                        fn.call(self, args)
                    }, dealy || 500)
              }
    }
```

``` javascript
    // throttle 节流
    function throttle (fn, delay) {
        var slef = this,
              timer = null,
              args = arguments;
              isImmediately = true
              if (isImmediately) {
                  fn.call(slef, args)
                  isImmediately = false
              }
              if (timer) {clearTimeout(timer)}
              timer = setTimeout(function () {
                  timer = null
                  fn.call(self, args)
              }, delay || 500)
    }

```

``` javascript`
    //  1
    var z = 10
    function foo () {
        console.log(z)
    }
    (function (funArg) {
        var z = 20
        funArg()
    })(foo)

    // input: 10  变量定义时已经决定了其作用域
```

``` javascript
    // 2 原型链
    Object.prototype.a = 'a'
    Function.prototype.a = 'a1'
    //person.prototype.a = 'a2'
    function person () {}
    var peter = new person()
    console.log(peter.a) // 'a'
    // peter =>   peter.prototype => Object.prototype
    var foo = {},
    F = function(){};
    Object.prototype.a = 'value a';
    Function.prototype.b = 'value b';

    console.log(foo.a)   // a
    console.log(foo.b)     // underfind
    console.log(F.a)      // a
    console.log(F.b)  // b
    //
    var y = 10,
          foo2
    (function() {
        var y = 20
        foo2 = function () {
            console.log(y)
        }
    })()      
    foo2() //  20
```

``` javascript

    // 手写new
    function create () {
        // 创建一个对象
        var obj = new Object()
        // 取出函数
        var fn = Array.prototype.shift.call(arguments)
        //  链接原型
        obj.__proto__ = fn.prototype
        // 绑定this
        let result = fn.call(obj, arguments)
        // 确定返回对象
        return typeof result === 'object' ? result : obj
    }
    // var foo = create(foo2)
```

``` javascript
   // 手写bind
    Function.prototype.bindNew () = function (fn) {
        var self = this,
              arg1 = Array.prototype.slice.call(arguments, 1)
            return function () {
                var agr2 = Array.prototype.slice.call(arguments),
                      args = arg1.concat(arg2)
                      return  self.apply(fn, args)
            }  
    }
```
